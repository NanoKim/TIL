# 목차

- [개요](#개요)
- [데이터 입출력](#데이터-입출력)
  - [데이터를 출력하는 구문](#데이터를-출력하는-구문)
  - [데이터를 입력받는 구문](#데이터를-입력받는-구문)
- [요소 접근하기](#요소-접근하기)
  - [아이디를 이용해서 요소 가져오기](#아이디를-이용해서-요소-가져오기)
  - [태그명을 이용해서 요소 가져오기](#태그명을-이용해서-요소-가져오기)
  - [name 속성값을 이용해서 요소 가져오기](#name-속성값을-이용해서-요소-가져오기)
  - [클래스를 이용해서 요소 가져오기](#클래스를-이용해서-요소-가져오기)
  - [선택자를 활용해서 자유롭게 요소 가져오기](#선택자를-활용해서-자유롭게-요소-가져오기)
- [변수와 자료형](#변수와-자료형)
- [문자열과 숫자](#문자열과-숫자)
  - [문자열 관련 기본 메소드](#문자열-관련-기본-메소드)
  - [문자열 관련 html 메소드](#문자열-관련-html-메소드)
  - [숫자(수학) 관련 메소드](#숫자수학-관련-메소드)
  - [문자들과 숫자간의 산술연산 / 형변환](#문자들과-숫자간의-산술연산--형변환)
- [배열](#배열)
- [함수](#함수)
- [객체](#객체)
- [window용 객체](#window용-객체)
- [이벤트](#이벤트)
- [정규표현식](#정규표현식)
- [정규표현식을 활용한 회원가입폼](#정규표현식을-활용한-회원가입폼)

# 개요

웹은 크게 3요소
- html : 웹 문서의 큰 틀
- CSS : 스타일(색상, 디자인, 간격, 배치 등)
- javascript : 웹 문서에서 이벤트가 발생했을 때 실행해야 되는 동작들 처리

**자바스크립트 개요**

스크립트 언어란?

프로그램의 동작을 사용자의 요구에 맞게 수행되도록 해주는 용도 → 매우 빠르게 배우고, 짧은 소스코드로 상호작용 되도록 고안

**자바스크립트**

웹 브라우저에서 많이 사용되는 "인터프리터 방식"의 스크립트 언어
\* 인터프리터 방식
- 코드를 한 줄씩 읽어가며 바로 실행하는 방식
- 실시간으로 텍스트 분석해서 실행
- 코드에 문법 오류가 있으면 실행 시점에서 알림

**장단점**

\* 장점
- 컴파일 과정 없이 인터프리터로 코드를 한 줄씩 읽어가며 바로 실행되기에 수행속도 빠르고, 코드 작성이 간단 (단순한 구조, 원칙)

\* 단점
- 웹에 특화된 기술 → 내부에서 제공하는 기능이 제한적
- html 소스코드에서 같이 작성하면 외부에 공개 → 보안의 취약점 발생

**자바스크립트 사용법**

inline(인라인) : 태그 내에 간단하게 소스코드를 작성해서 실행되게 하는 방법
```html
<button onclick="window.alert('알람창 출력 버튼 클릭')">알람창 출력</button>
<button onclick="console.log('콘솔 출력 버튼 클릭')">콘솔 출력</button>
```

internal(내부) : html문서 내에 소스코드를 작성해서 실행되게 하는 방법
```html
<button id="btn">알람창 출력</button>
<button onclick="btnClick()">콘솔 출력</button>

<script>
  var btn = document.getElementById("btn");

  // 익명함수
  btn.onclick = function(){ 
      window.alert('버튼 클릭');
  }
          
  // 이름있는 함수 정의해보기
  function btnClick(){
      console.log('콘솔 버튼 클릭');
  }
</script>
```

external(외부) : 별도의 .js 파일로 소스코드를 작성해서 실행되게 하는 방법

# 데이터 입출력

\* window
- 자바스크립트 내장 객체로 브라우저 창이 열릴때 마다 하나씩 만들어지는 객체
- 브라우저 창 안에 존재하는 모든 요소들의 최상위 객체(생략가능)

\* document
- 웹 문서마다 하나씩 만들어지는 객체 (html 문서에 대한 정보들을 지님)

위 두 객체들은 별도로 객체를 생성하지 않아도 자동으로 만들어짐

## 데이터를 출력하는 구문
1) [window.]alert("알람창에 출력할 문구");
2) [window.]console.log("콘솔창에 출력할 문구");
3) document.write("화면상에 출력할 문구");
4) 선택한 요소.innerHTML | innerText = "요소에 출력할 문구";

## 데이터를 입력받는 구문
1) 변수 = [window.]confirm("질문내용");
  - confirm 호출 시 "질문내용"과 확인|취소 버튼이 존재하는 알람창 발생
  - 확인버튼 클릭시 true, 취소버튼 클릭시 false 반환
2) 변수 = [window.]prompt("질문내용");
  - prompt 호출 시 "질문내용"과 입력할 수 있는 "텍스트 상자"와 "확인/취소" 버튼이 보여지는 알람창 발생
  - 확인 버튼 클릭시 텍스트 상자에 입력되어 있는 값이 문자열로 반환 (숫자가 있어도 문자열로 넘어옴)
  - 취소 버튼 클릭시 (글자 입력을 했어도 취소를 누르면 무조건) null 반환
3) 변수 = 선택한요소.속성(id, className, innerHTML, innerText, ...);
4) 변수 = 선택한 input 요소.value;

# 요소 접근하기

## 아이디를 이용해서 요소 가져오기
```html
<h3>1) 아이디를 이용해서 요소 가져오기</h3>
<div id="area1" class="area"></div>
<button onclick="accessId();">아이디로 접근</button>

<script>
    function accessId(){
        var area1 = document.getElementById("area1");

        area1.innerHTML += "아이디로 접근 성공 <br>";

        area1.style.backgroundColor = "pink";
        area1.style.color = "red";
        area1.style.width = "200px";
        area1.style.height = "200px";
    }
</script>
```

![image](https://github.com/NanoKim/TIL/assets/151509995/b52c79a2-89cf-4203-bc8b-960f6c5a44ee)

## 태그명을 이용해서 요소 가져오기
```html
<ul>
    <li>목록1</li>
    <li>목록2</li>
    <li>목록3</li>
    <li>목록4</li>
    <li>목록5</li>
</ul>

<button onclick="accessTagName();">태그명으로 접근</button>

<script>
    function accessTagName(){
        // 단, 해당 HTML 문서의 모든 해당 태그들이 다 선택
        // 선택된 요소객체들이 배열에 담겨서 반환
        var list = document.getElementsByTagName("li"); // [li요소객체, li요소객체, ...]

        console.log(list);
        console.log("배열의 크기(선택된 li 요소 개수) : " + list.length);

        console.log(list[0]);

        list[0].innerHTML = "안녕하세요";

        var blueColor = 50;
        for(var i = 0; i < list.length; i++){
            list[i].innerHTML = "안녕하세요";
            // list[i].style.backgroundColor = "yellow";
            list[i].style.backgroundColor = "rgb(130, 220," + blueColor + ")";
            blueColor += 50;
        }
    }
</script>
```

![image](https://github.com/NanoKim/TIL/assets/151509995/c5749929-5551-4539-8788-b2ef87d7acfd) ![image](https://github.com/NanoKim/TIL/assets/151509995/9db41345-158d-4a58-857e-ae1b5c526bd6)

## name 속성값을 이용해서 요소 가져오기
```html
<form action="#">
    <fieldset>
        <legend>취미</legend>

        <input type="checkbox" name="hobby" value="game" id="game">
        <label for="game">게임</label>

        <input type="checkbox" name="hobby" value="movie" id="movie">
        <label for="movie">영화감상</label>

        <input type="checkbox" name="hobby" value="reading" id="reading">
        <label for="reading">독서</label>

        <input type="checkbox" name="hobby" value="sports" id="sports">
        <label for="sports">운동</label>
    </fieldset>
</form>

<br>
<div class="area" id="area3"></div>
<button onclick="accessName();">name으로 접근</button>

<script>
    function accessName(){
        // 선택된 요소들이 배열에 담겨 반환

        var hobby = document.getElementsByName("hobby"); // [input요소 객체, input요소 객체, ...]

        for(var i = 0; i < hobby.length; i++){
            if(hobby[i].checked){
                area3.innerHTML += hobby[i].value + "<br>";
                // 이렇게 area3 이라고 해도 ok
            }
        }
    }
</script>
```

![image](https://github.com/NanoKim/TIL/assets/151509995/87af325e-04ca-4159-a27f-83ed7ff53ac2)

## 클래스를 이용해서 요소 가져오기
```html
<div class="test"></div>
<p class="test"></p>
<ul class="test">
    <li></li>
    <li></li>
</ul>
<pre class="test test1"></pre>

<button onclick="accessClass();">클래스로 접근</button>

<script>
    function accessClass(){
        // 선택된 요소들이 배열에 담겨 반환
        var arr = document.getElementsByClassName("test");
    }
</script>
```

![image](https://github.com/NanoKim/TIL/assets/151509995/32002ca6-7214-4781-a88b-3fd3c9b8c811)

## 선택자를 활용해서 자유롭게 요소 가져오기
```html
<div id="test1">테스트입니다.</div>
<div class="test">
    <h2>ㅎㅇ</h2>
    <h2>ㅂㅇ</h2>
</div>
<span>ㅋㅋㅋ</span>
<h2>ㅃㅃ</h2>

<br>

<button onclick="accessSelector();">클릭</button>

<script>
    function accessSelector(){
        // document.querySelector("선택자") → 선택된 요소객체 하나만 반환
        // document.querySelectorAll("선택자") → 선택된 요소객체들을 배열에 담아 반환

        var divEl = document.querySelector("#test1"); // div 요소 객체
        var h2El = document.querySelectorAll(".test>h2"); // [h2요소객체, h2요소객체]
        var spanEl = document.querySelector(".test+span"); // span 요소 객체

        for(var i = 0; i < h2El.length; i++){
            console.log(h2El[i].innerHTML);
        }
    }
</script>
```

![image](https://github.com/NanoKim/TIL/assets/151509995/119eeea9-f036-4a6a-afa0-1a79ee25a0e9)

# 변수와 자료형

**var, let, const의 차이점**
- var : 중복선언 및 재할당 가능
- let : 중복선언 불가능 및 재할당 가능
- const : 중복선언 및 재할당 불가능

```html
<button onclick="diffDeclare();">클릭</button>
<script>
    function diffDeclare(){
        var userId = "user01";
        console.log(userId); // user01 출력

        var userId = "user02";
        console.log(userId); // user02 출력

        userId = "user03"; // 재할당
        console.log(userId); // user03 출력

        // -------------------------------

        let userPwd = "pass01";
        console.log(userPwd); // pass01 출력

        // let userPwd = "pass02"; // 오류 발생
        // console.log(userPwd);

        userPwd = "pass02"; // pass02 출력
        console.log(userPwd);

        // -------------------------------

        const userName = "피카츄";
        console.log(userName);

        // const userName = "라이츄"; // 오류 발생
        // console.log(userName);

        // userName = "라이츄";
        // console.log(userName); // constant variable // 오류 발생
    }
</script>

var는 자유롭게 변수 선언, 사용 가능하다는 장점이 있으나 중복된 변수 남발할 수 있고, 의도치 않게 값이 변경될 수 있다
→ 보완해서 나온 게 let, const

\*권장사항 : let, const를 위주로 사용 (개발가이드에 따라 사용)
```

**변수 선언 위치에 따른 전역변수 / 지역변수**
```html
<script>
    var declareVar = "var로 전역변수";
    let declareLet = "lef로 전역변수";
    const declareConst = "const로 전역변수";

    declareNone = "그냥 전역변수"; // 이렇게도 되긴 하지만 사용은 잘 하지 않는다

    // 윈도우가 onload 되었을 때
    // window.onload = function(){이 문서가 로딩된 직후에 실행시킬 코드};
    window.onload = function(){
        console.log("문서 로딩 완료");

        // 전역변수와 동일한 이름으로 지역변수 선언
        var declareVar = "var로 지역변수";
        let declareLet = "lef로 지역변수";
        const declareConst = "const로 지역변수";

        console.log(declareVar);
        console.log(declareLet);
        console.log(declareConst);
        console.log(declareNone);
        // 기본적으로 지역변수명이랑 전역변수명이 중복될 경우 → 지역변수를 우선시 찾음

        //==============================================================

        // 이 때 무조건 전역변수에 접근하고자 한다면? window. 또는 this. 으로 접근
        console.log(window.declareVar);
        console.log(this.declareVar);

        // let, const 는 불가능
        console.log(window.declareLet); // undefined
        console.log(this.declareConst); // undefined

        //==============================================================

        declareNone1 = "얘는 뭘까";
        console.log(declareNone1);          // 얘는 뭘까 출력
        console.log(window.declareNone1);   // 얘는 뭘까 출력
        console.log(this.declareNone1);     // 얘는 뭘까 출력

        // 앞에 전역변수 declareNone1 이 없으니 window 와 this 는 undefined 가 떠야할텐데,,
        // → 특정 함수 내에 var let const 를 사용않고 선언된 변수는 전역변수로 잡힘
        test();
    }

    function test(){
        console.log(declareNone1);
        // declareNone1 은 위의 함수 내에서 사용된 지역변수였으나,
        // var let const 를 사용않고 선언됐기에 전역변수로 잡혀 undefined가 아닌 얘는 뭘까 출력
    }
</script>
```

**자료형**

변수 선언시 자료형을 별도로 지정하지 않음 (자료형의 개념이 없는 건 아님) → 변수에 대입되는 값(리터럴)에 따라서자료형이 결정됨
- string(문자열)
- number(숫자)
- boolean(논리값)
- object(객체)
- function(함수)
- undefined(초기화가 되지 않은 변수)

```html
<div id="area" style="border: 1px solid black;"></div>

<script>
    function typeTest(){
        const name = '피카츄'; // 문자열 값 제시할 때 홑따옴표(''), 쌍따옴표("") 모두 가능
        const age = 20;
        const flag = true;

        const hobby = ["영화", "음악", '낮잠'];         // 배열 객체
        const divEl = document.querySelector("#area"); // 요소 객체
        const user = {
            name : "파이리",
            age : 30,
            id : "user01"
        }

        const testFn = function(){ // 이름 없는 함수 (익명함수)
            alert()="zzzzzzz)";
        }

        // const noVal; // const 는 상수라서 선언과 동시에 초기화 필요
        let noVal;

        // 콘솔에 출력
        console.log(name);
        console.log(age);
        console.log(flag);
        console.log(hobby);
        console.log(divEl);
        console.log(user);
        console.log(testFn);
        console.log(noVal);

        // 화면에 출력(텍스트로 출력되기에 콘솔출력과 결과 다를 수 있음)
        // 자료형 확인 시 사용하는 함수 : typeof(변수명)
        divEl.innerHTML = name + ", " + typeof(name) + "<br>";
        divEl.innerHTML += age + ", " + typeof(age) + "<br>";
        divEl.innerHTML += flag + ", " + typeof(flag) + "<br>";
        divEl.innerHTML += hobby + ", " + typeof(hobby) + "<br>";
        divEl.innerHTML += divEl + ", " + typeof(divEl) + "<br>";
        divEl.innerHTML += user + ", " + typeof(user) + "<br>";
        divEl.innerHTML += testFn + ", " + typeof(testFn) + "<br>";
        divEl.innerHTML += noVal + ", " + typeof(noVal) + "<br>";
    }
</script>
```

# 문자열과 숫자

## 문자열 관련 기본 메소드

|메소드|기능|
|---|---|
|str.toUpperCase()|대문자로 변환|
|str.toLowerCase()|소문자로 변환|
|str.length|문자열의 길이|
|str.charAt(index)|index 문자 추출|
|str.indexOf("c")|앞에서부터 첫 c의 위치 (없을 시 -1)|
|str.lastIndexOf("c"|뒤에서부터 첫 c의 위치 (없을 시 -1)|
|str.substring(시작인덱스[, 끝인덱스])|문자열 추출|
|str.split("구분자")|구분자 기준 문자열 나눠 배열 반환|

## 문자열 관련 html 메소드

|메소드|기능|
|---|---|
|str.bold()|문자열 굵게|
|str.italics()|문자열 눕히기|
|str.small()|문자열 작게|
|str.big()|문자열 크게|
|str.sup()|윗첨자|
|str.sub()|아랫첨자|
|str.link("link")|문자열 link 연결|

## 숫자(수학) 관련 메소드

|메소드|기능|
|---|---|
|Math.abs(num)|절대값|
|Math.random()|랜덤값|
|Math.round(num)|반올림|
|Math.floor(num)|버림|
|Math.ceil(num)|올림|

## 문자들과 숫자간의 산술연산 / 형변환

```html
const test1 = 7 + 7;            // 14
const test2 = 7 + "7";          // "77"
const test3 = "7" + 7;          // "77"
const test4 = "7" + 7 + 7;      // "77" + 7 = "777"
const test5 = "7" + (7 + 7);    // "7" + 14 = "714"
```

js 에서는 + 연산자 외의 산술연산 가능
- 문자열이 자동형변환(문자열 > 숫자형) 돼서 숫자로 산술연산 가능
- 단, 문자열에는 숫자만 존재

```html
const test6 = "7" - 7;          // 7 - 7 = 0
const test7 = "7" * 7;          // 7 * 7 = 49
const test8 = "7" / 7;          // 7 / 7 = 1

const area4 = document.querySelector("#area4");
area4.innerHTML = "test6 : " + test6 + "<br>";
area4.innerHTML += "test7 : " + test7 + "<br>";
area4.innerHTML += "test8 : " + test8 + "<br>" + "<br>";
```

덧셈연산을 할 때는 자동 형변환이 되지 않아 연이어서 한 문자열

**강제형변환 (문자열 > 숫자형)**
1) Number(문자열)
2) parseInt(문자열)   → 문자열 정수일 때 주로 사용
3) parseFloat(문자열) → 문자열 실수일 때 주로 사용

```html
// 2, "3" 덧셈연산
const test9 = 2 + "3";                       // 23
const test10 = 2 + Number("3");              // 5
const test11 = 2 + parseInt("3");            // 5
const test12 = 2 + parseFloat("3");          // 5

// 2, "1.234" 덧셈연산
const test13 = 2 + "1.234"                   // "21.234"
const test14 = 2 + Number("1.234");          // 2 + 1.234 = 3.234
const test15 = 2 + parseInt("1.234");        // 2 + 1 = 3
const test16 = 2 + parseFloat("1.234");      // 2 + 1.234 = 3.234
```

# 배열

변수 선언시 별도의 자료형 지정이 없기에 어떤 자료형의 값들이든 다 하나의 배열 공간에 담을 수 있고, 크기의 제약도 없다. (자바에서의 Collection 과 유사)

```html
<script>
    function arrayTest1(){
        const arr = ["문동은", '서울', 20, true, [1,2,3]]; // 배열객체 (type == object)

        console.log(arr);
        console.log(arr[2]);
        console.log(arr[4]);
        console.log(arr[4][2]);

        const area1 = document.getElementById("area1");

        // 일반 for문
        for(let i = 0; i < arr.length; i++){
            area1.innerHTML += arr[i] + "<br>";
        }

        // for in문(향상된 for문)
        for(변수 in 순차적으로 접근할 배열){}

        for(let v in arr){
            area1.innerHTML += arr[v] + "<br>";
        }
    }
</script>
```

**배열의 선언**

```html
<script>
    function arrayTest2(){
        // 배열 선언
        const arr1 = new Array();   // 빈 배열 []
        const arr2 = new Array(3);  // 크기가 3인 빈 배열 [empty × 3]
        const arr3 = [];            // 빈 배열 []

        // 배열에 값 대입
        arr1[0] = "바나나";
        arr1[1] = "사과";
        arr1[9] = "키위";            // 크기가 10빈 배열 ['바나나', '사과', empty × 7, '키위']

        arr2[0] = "자동차";
        arr2[1] = "기차";
        arr2[2] = "오토바이";
        arr2[6] = "제트기";          // ['자동차', '기차', '오토바이', empty × 3, '제트기']    

        // 배열 선언과 동시에 초기화
        const arr4 = new Array("문동은", "이사라", "박연진");
        const arr5 = ["java", "oracle", "front"];
    }
</script>
```

**배열 관련 메소드**

|메소드|기능|
|---|---|
|indexOf(찾고자하는요소)|배열에서 해당 요소가 위치해있는 인덱스 반환|
|배열.concat(배열, 배열, ...)|배열에 여러개의 배열을 결합|
|배열.reverse()|배열에 담긴 값들을 역순으로|
|배열.sort()|배열안에 담긴 값들을 오름차순 정렬|
|배열.push(추가할요소)|배열의 맨 뒤에 요소 추가시키고 배열의 크기 반환|
|배열.pop()|배열의 맨 뒤 요소 제거시키고 제거된 요소 반환|
|배열.unshift(추가할요소)|배열의 맨 앞에 요소 추가시키고 배열의 크기 반환|
|배열.shift()|배열의 맨 앞 요소 제거시키고 제거된 요소 반환|
|배열.slice(시작인덱스, 끝인덱스)|배열로부터 시작인덱스~끝인덱스 까지 추출 메소드|
|배열.splice(시작인덱스, 제거개수[, 추가할값])|배열의 요소 추출해서 제거 및 추가|
|배열.toString() / 배열.join([구분자])|배열의 각 인덱스에 담긴 값들을 하나의 "문자열"로 합쳐서 반환|

# 함수


# 객체


# window용 객체


# 이벤트


# 정규표현식


# 정규표현식을 활용한 회원가입폼


