# 목차

- [개요](#개요)
- [1. 요구사항 확인](#1-요구사항-확인)
- [2. 데이터 입출력 구현](#2-데이터-입출력-구현)
- [3. 통합 구현](#3-통합-구현)
- [4. 서버 프로프갬 구현](#4-서버-프로그램-구현)
- [5. 인터페이스 구현](#5-인터페이스-구현)
- [6. 화면 설계](#6-화면-설계)
- [7. 애플리케이션 테스트 관리](#7-애플리케이션-테스트-관리)
- [8. SQL 응용](#8-sql-응용)
- [9. 소프트웨어 보안 구축](#9-소프트웨어-보안-구축)
- [10. 프로그래밍 언어 활용](#10-프로그래밍-언어-활용)
- [11. 응용 SW 기초 기술 활용](#11-응용-sw-기초-기술-활용)
- [12. 제품소프트웨어 패키징](#12-제품소프트웨어-패키징)

# 개요
__TBU__

# 1. 요구사항 확인
**Case(Computer Aided Software Engineering)**

소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것

- 소프트웨어 생명 주기 전 단계의 연결
- 다양한 소프트웨어 개발 모형 지원
- 그래픽 지원

<br>

**COCOMO(COnstructive COst MOdel)**

LOC에 의한 비용 산정 기법

- 조직형(organic Mode) 중 소 규모의 소프트웨어 5만라인 이하
- 반 분리형(Semi-Detached Mode) 중간형 소프트웨어 30만 라인 이하의 소프트웨어
- 내장형(Embedded Mode) 초대형 규모의 소프트웨어 30만 라인 이상

<br>

**Putnam**

소프트웨어 생명주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모델

<br>

**기능 점수 모형**

소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하고,

요인별 가중치를 합산하여 총 기능 점수를 산출하며, 총 기능 점수와 영향도를 이용하여 점수를 구한 후 이를 이용하여 비용을 산정

<br>

**소프트웨어 개발 프레임워크의 특성**

- 모듈화
- 재사용성
- 확장성
- 제어의 역흐름

<br>

# 2. 데이터 입출력 구현
**데이터베이스 설계 순서**

- 요구조건 분석
- 개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R모델
- 논리적 설계 : 논리 스키마 설계, 트랜잭션 인터페이스 설계
- 물리적 설계 : 물리적 구조의 데이터로 변환
- 구현 : DDL로 데이터베이스 생성, 트랜잭션 작성

**데이터 모델**

- 구조 (Structure) : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현
- 연산 (Operation) : 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 병세로서 데이터베이스를 조작하는 기본 도구
- 제약 조건 (Constraint) : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

**관계형 데이터베이스의 릴레이션 구조**

- 튜플 : 릴레이션을 구성하는 각각의 행
- 속성 : 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
- 도메인 : 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자 값들의 집합

**key**

- 후보키 (Candidate Key)
  - 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합
  - 후보키는 유일성과 최소성을 모두 만족시켜야 한다.
- 기본키(Primary Key)
  - NULL X, 유일하게 식별할 수 있는 키값 → 중복 X
- 대체키(Alternate Key)
  - 후보키가 둘 이상일 때 기본 키를 제외한 나머지 후보키
- 슈퍼키(Super Key)
  - 릴레이션 내에 있는 속성들의 집합으로 구성된 키
  - 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다.
- 외래키(Foreign Key)
  - 다른 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합을 의미
  - 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.

**무결성(Integrity)

신뢰할 수 있는 서비스 제공을 위해서 의도하지 않은 요인에 의해 데이터, 소프트웨어, 시스템 등이 변경되거나 손상되지 않고 완전성, 정확성, 일관성을 유지함을 보장하는 특성

- 개체 무결성 : 기본 테이블의 기본 키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다는 규정
- 참조 무결성 : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정

**순수 관계 연산자**

- Select σ 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분 집합을 구하여 새로운 릴레이션을 만드는 연산
- Project π 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
- Join ▷◁ 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산자 Join의 결과는 Cartesian Product(교차 곱)를 수행한 다음 Select를 수행한 것과 같다.
- Division ÷ 릴레이션 A, B가 있을 때 릴레이션 B의 조건에 맞는 것들만 릴레이션 A에서 분리하여 프로젝션을 하는 연산이다.

**일반 집합 연산자**

- 합집합(UNION) 두 릴레이션에 존재하는 튜플의 합집합을 구하되 결과로 생성된 릴레이션에서 중복되는 튜플은 제거
- 교집합(INTERSECTION) 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산
- 교차곱(CARTESIAN PRODUCT) 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산

**이상(Anomaly)**

데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 않게 발생하는 곤란한 현상

- 삽입이상(Insertion Anomaly) 테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상
- 삭제 이상(Deletion Anomaly) 테이블에서 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상
- 갱신 이상(Update Anomaly) 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성(Inconsistency)이 생기는 현상

**정규화 과정**

![image](https://github.com/NanoKim/TIL/assets/151509995/7c5daff3-c33d-4ecc-88dd-323ab1ac3090)

- 제 1 정규형(1NF) 테이블의 모든 속성 값이 원자값으로만 되어있는 정규형
- 제 2 정규형(2NF) 1NF + 기본키가 아닌 모든 속성이 기본키에 대하여 관전 함수적 종속을 만족하는 정규형
- 제 3 정규형(3NF) 2NF + 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정규형이다.
- BCNF(Boyce-Codd Normal Form) 테이블에서 모든 결정자가 후보키(Candidate Key)인 정규형 일반적으로 제 3 정규형에 후보키가 여러 개 존재하고, 이러한 후보키들이 서로 중첩되어 나타나는 경우에 적용 가능하다.
- 제 4 정규형(4NF) 테이블 R에 다중값 종속 A→→B가 존재할 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형이다.

**반 정규화(Denormalization)**

시스템의 성능을 향상하고 개발 및 운영의 편의성 등을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위

시스템 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다.

**트랜잭션**

데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

- Atomicity(원자성) 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 함
- Consistency(일관성) 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
- Isolation(독립성) 둘 이상의 트랜잭션이 동시에 병행 실행 되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음
- Durability(영속성) 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

**인덱스(Index)**

데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조

**뷰(view)**

하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블

뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다.

**분산데이터베이스의 목표**

- 위치 투명성(Location Transparency) 데이터베이스의 논리적인 명칭만으로 액세스 할 수 있음
- 중복 투명성(Replication Transparency) 동일 데이터가 여러곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행함
- 병행투명성(Concurrency Transparency) 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
- 장애 투명성(Failure Transparency) 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리함

**RTO/RPO**

- RTO(Recovery Time Objective) 목표 복구 시간 비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요시간
- RPO(Recovery Point Objective) 목표 복구 시점 비상사태 또는 업무 중단 시점으로부터 데이터를 복구 할 수 있는 기준점을 의미함

**임의 접근 통제 (DAC)**

DAC(Discretionary Access Control)은 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식

데이터 소유자가 접근 통제 권한을 지정하고 제어한다.

**강제 접근 통제 (MAC)**

MAC(Mandatory Access Control)은 주체와 객체의 등릅을 비교하여 접근 권한을 부여하는 방식

사용자별로 인가 등급을 부여할 수 있다.

시스템이 접근 통제 권한을 지정한다.

**DAS/NAS/SAN**

- DAS(Direct Attached Storage) 서버와 저장장치를 전용 케이블로 직접 연결하는 방식이다.
- NAS(Network Attached Storage) 서버와 저장장치를 네트워크를 통해 연결하는 방식이다.
- SAN(Storage Area Network) DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식이다.

# 3. 통합 구현
**연계서버 / 송 수신 시스템**

- 연계서버 데이터를 전송 형식에 맞게 변환하고 송 수신을 수행하는 등 송 수신과 관련된 모든 처리 수행
- 송신 시스템 인터페이스 테이블 또는 파일의 데이터를 전송 형식에 맞도록 변환 및 송신을 수행하는 시스템
- 수신 시스템 수신 데이터를 인터페이스 테이블이나 파일로 생성하는 시스템

**XML**

특수한 목적을 갖는 마크업 언어를 만드는데 사용되는 다목적 마크업 언어이다.

웹 브라우저 간 HTML문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위하여 개발되었다.

트리구조로 구성되어있어 상위 태그는 여러개의 하위 태그를 가질 수 있다.

**SOAP**

SOAP(Simple Object Access Protocol)는 컴퓨터 네트워크 상에서 HTTP/HTTPS, SMTP등을 이용하여 XML을 교환하기 위한 통신 규약이다.

기본적으로 HTTP 기반에서 동작하기 때문에 프록시와 방화벽의 영향 없이 통신할 수 있다.

최근에는 무거운 구조의 SOAP 대신 RESTful 프로토콜을 이용하기도 한다.

**WSDL**

WSDL(Web Services Description Language)은 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어이다.

XML로 작성되며 SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용된다.

클라이언트는 WSDL 파일을 읽어 서버에서 어떠한 조작이 가능한지를 파악할 수 있다.

# 4. 서버 프로그램 구현
**모듈화**

모듈화는 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미한다.

모듈화는 모듈 간 결합도(Coupling)의 최소화와 모듈 내 요소들의 응집도(Cohesion)를 최대화 하는 것이 목표이다.

**추상화**

추상화는 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다.

**정보 은닉**

한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다.

하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다.

**소프트웨어 아키텍처의 품질 속성**

- 시스템측면 성능, 보안, 가용성, 기능성, 사용성, 변경용이성, 확장성 등
- 비즈니스 측면 시장 적시성, 비용과 혜택, 예상시스템 수명, 목표 시장, 공개 일정 등
- 아키텍처 측면 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성 등

**아케텍처 패턴**

아키텍처를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제를 의미한다.

- 레이어 패턴 시스템을 계층으로 구분하여 구성하는 고전적인 방법의 패턴 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어진다.
- 클라이언트-서버 패턴 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다. 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에게 제공하는 방식이다.
- 파이프 필터 패턴 데이터 스트림 절차의 각 단계를 필터로 캠슐화하여 파이프를 통해 전송하는 패턴 데이터변환, 버퍼링, 동기화등에 주로 사용된다. → UNIX의 쉘이 있다.
- 모델-뷰-컨트롤러 패턴 서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴이다. 컨트롤러가 사용자의 요청을 받으면 핵심기능과 데이터를 보관하는 몯ㄹ을 이용하여 뷰에 정보를 출력하는 구조이다.
- 마스터-슬레이브 패턴 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴 ex) 장애 허용 시스템, 병렬 컴퓨팅 시스템
- 브로커 패턴 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 ㅁㅈ는 컴포넌트와 사용자를 연결해주는 패턴 ex) 분산 환경 시스템
- 피어-투-피어 패턴 Peer라 불리는 하나의 컴포넌트가 클라이언트가 될 수도 서버가 될 수도 있는 패턴이다. ex) 파일 공유 네트워크
- 이벤트-버스 패턴 소스가 특정 채널에 이번트 메시지를 발행(publish) 하면 해당 채널을 구독(Subscribe)한 구독자들이 메시지를 받아 이벤트를 처리하는 패턴이다. ex)알림 서비스, mosquitto
- 블랙보드 패턴 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴이다. ex) 음성인식, 차량 식별, 신호 해석
- 인터프리터 패턴 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴이다. ex) 번역기, 컴파일러 인터프리터

**객체지향**

소프트웨어의 각 요소들을 객체로 만든 후 객체들을 조립해서 소프트웨어를 개발하는 기법이다.

- 클래스 클래스는 공통된 속성과 연산을 갖는 객체의 집합이다. 클래스에 속한 각각의 객체를 인스턴스라고 한다.
- 캡슐화 외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것이다. 객체들 간에 메시지를 주고 받을 때 상대 객체의 세부 내용을 알 필요가 없으므로 인터페이스가 단순해지고, 객체간의 결합도가 낮아진다.
- 상속 상위 클래스의 모든 속성과 연산을 하위 클래스가 전달받아 새로운 형태의 클래스로 확장하여 사용할 수 있다.
- 다형성 상속받은 여러개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있다. ex) sum(int a, int b) 와 sum(string a, string b)와 같이 인자들의 형태에 따라 다른 메서드로 인식한다.
- 연관성 두 개 이상의 객체들이 상호 참조하는 관계

|종류|의미|특징|
|----|----|----|
|is member of|연관화||
|Association|2개 이상의 객체가 상호관련되어 있음을 의미함||
|is instance of|분류화||
|Classification|동일한 형의 특성을 갖는 객체들을 모아 구성하는것||
|is part of|집단화||
|Aggregation|련있는 객체들을 묶어 하나의 상위 객체를 구성하는 것||
|is a|일반화||
|Generalization|공통적인 성질들로 추상화 한 상위 객체를 구성하는 것||
|is a|특수화/상세화||
|Specialization|상위 객체를 구체화하여 하위 객체를 구성하는 것||

**객체지향 분석**

객체지향 분석(OOA : Object Oriented Analysis)는 사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업이다.

- Rumbaugh(럼바우) 방법 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법 분석 활동을 객체 모델링 → 동적 모델링 → 기능 모델링 으로 나누어 수행 객체 모델링 : 객체들 간의 관계를 규정하여 객체 다이어그램으로 표현 동적 모델링 : 상태 다이어그램을 이용하여 제어흐름, 상호작용, 동작 순서 등의 동적인 행위를 표현 기능 모델링 : 자료 흐름도를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현
- Booch(부치) 방법 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함
- Jacobson 방법 유스케이스를 강조하여 사용함
- Coad와 Yourdon 방법 E-R 다이어그램을 사용하여 객체의 행위를 모델링하며 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 수행함
- Wirfs-Brock 방법 분석과 설계간의 구분이 없고, 곡객 명세서를 평가해서 설계 작업까지 연속적으로 수행함

**객체지향 설계 원칙(SOLID 원칙)**

- 단일 책임 원칙(SRP) : 객체는 단 하나의 책임만 가져야 한다.
- 개방-폐쇄 원칙(OCP) : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야한다.
- 리스코프 치환 원칙(LCP) : 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙
- 인터페이스 분리 원칙(ISP) : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
- 의존 역전 원칙(DIP) : 의존 관계 성립 시 추상성이 높은 클래스와 의존관계를 맺어야 한다는 원칙

**결합도(Coupling)**

모듈간에 상호 의존하는 정도 또는 두 모듈사이의 연관 관계이다.

결합도가 약할 수록 품질이 높고, 강할 수록 품질이 낮다.

- 내용 결합도(Content Coupling) 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도이다.
- 공통(공유) 결합도(Common Coupling) 공유 되는 공통 데이터 영역을 여러 보듈이 사용할 떄의 결합도이다.
- 외부 결합도(External Coupling) 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도이다.
- 제어 결합도(Control Coupling) 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도
- 스탬프 결합도(Stamp Coupling) 모듈 간의 인터페이스로 배열이나 레코드 등의 자료구조가 전달될 떄의 결합도이다.
- 자료 결합도(Data Coupling) 모듈 간의 인터페이스가 자료 요소로만 구성될 떄의 결합도

**응집도(Cohesion)**

모듈의 내부 요소들이 서로 관련되어있는 정도이다.

응집도가 강할 수록 품질이 높고, 약할 수록 품질이 낮다.

- 기능성 응집도(Functional Cohesion) 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도이다.
- 순차적 응집도(Sequential Cohesion) 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그다음 활동의 입력데이터로 사용할 경우의 응집도이다.
- 교환(통신)적 응집도(Communication Cohesion) 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도이다.
- 절차적 응집도(Procedural Cohesion) 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도이다.
- 시간적 응집도(Temporal Cohesion) 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도이다.
- 논리적 응집도(Logical Cohesion) 유사한 성격을 갖거나 특정 형태로 분류되는 처리요소들로 하나의 모듈이 형성되는 경우의 응집도이다.
- 우연적 응집도(Coincidental Cohesion) 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도이다.

**팬인/팬아웃**

- 팬인(Fan-in) 은 어떤 모듈을 제어하는 모듈의 수이다.
- 팬아웃(Fan-out)은 어떤 모듈에 의해 제어되는 모듈의 수를 의미한다.

**IPC(Inter-Process Communication)**

IPC는 모듈간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합이다.

- 공유메모리
- 소켓
- 세마포어
- 파이프와 네임드 파이프
- 메시지 큐잉

등의 메서드가 있다.

**공통 모듈 명세 기법의 정류**

- 정확성(Correctness) : 시스템 구현시 해당 기능의 필요성을 정확히 작성
- 명확성(Clarity) : 해당 기능을 명확하게 작성
- 완전성(Completeness) : 시스템 구현을 위해 필요한 모든 것을 기술
- 일관성(Consistency) : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
- 추적성(Traceability) : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성

**디자인 패턴**

디자인 패턴은 모듈간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제를 의미한다.

GoF의 디자인 패턴은 생성패턴, 구조패턴, 행위 패턴으로 구분된다.

**생성패턴**

생성패턴(Creational Pattern)은 클래스나 객체의 생성과 참조 과정을 정의하는 패턴이다.

- 추상팩토리(Abstract Factory) 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관-의존하는 객체들의 그룹으로 생성하여 추상적으로 표현하는 패턴
- 빌드(Builder) 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성하는 패턴 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다.
- 팩토리 메서드(Factory Method) 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다. 상위클래스에서 인터페이스만 정의하고, 실제 생성은 서브 클래스가 담당한다.
- 프로토타입(Prototype) 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
- 싱글톤(Singleton) 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없는 패턴이다. 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있다.

**구조 패턴**

구조패턴(Structural Pattern)은 구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴이다.

- 어댑터(Adapter) 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴이다. 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용한다.
- 브리지(Bridge) 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴이다.
- 컴포지트(Composite) 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴이다. 객체들을 트리 구조로 구성하여 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있다.
- 데코레이터(Decorator) 객체간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴이다. 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현한다.
- 퍼싸드(Facade) 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴이다. 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요하다.
- 플라이웨이트(Flyweight) 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴이다.
- 프록시(Proxy) 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴이다. 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용한다.

**행위 패턴**

행위 패턴(Behavioral pattern)은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다.

- 책임연쇄(Chain of Responsibility) 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
- 커맨드(Command) 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
- 인터프리터(Interpreter) 언어에 문법 표현을 정의하는 패턴 SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용한다.
- 반복자(Iterator) 자료구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴이다. 내부 표현의 방법과 노출 없이 순차적인 접근이 가능하다.
- 중개자(Mediator) 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴 객체들 사이의 의존성을 줄여 결합도를 감소시킬 수 있다.
- 메멘토(Memento) 특정 시점에서의 객체 내부 상태를 객체화 함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
- 옵저버(Observer) 한 객체의 상태가 변화하면 객체에 상속되어있는 다른 객체들에게 변화된 상태를 전달하는 패턴 주로 분산된 시스템 간에 이벤트를 생성-발행(publish)하고, 이를 수신(subscribe)해야할 때 사용한다.
- 상태(State) 객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용하는 패턴 객체의 상태를 캡슐화하고, 이를 참조하는 방식으로 처리한다.
- 전략(Strategy) 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향없이 알고리즘의 변경이 가능하다.
- 템플릿 메서드(Template Method) 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴이다. 유사한 서브클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고, 유지보수를 용이하게 해준다.
- 방문자(Visitor) 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴 분리된 처리 기능은 각 클래스를 방문하여 수행한다.

**배치 프로그램**

배치 프로그램은 사용자의 상호작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램이다.

# 5. 인터페이스 구현
**요구사항 검토**

요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 결함 여부를 검토 담당자들이 수작업으로 분석하는 방법이다.

- 동료 검토(Peer Review) 동료들이 시스템의 결함을 발견하는 형태의 검토 방법
- 워크 스루(Walk Through) 요구사항 명세서를 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토방법
- 인스펙션(Inspection) 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견하는 형태의 검토 방법
- 프로토타이핑(Prototyping) 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품(Prototype)을 만들어 최종 결과물을 예측한다.
- 테스트 설계 요구사항은 테스트할 수 있도록 작성되어야 하며, 이를 위해 테스트케이스를 생성하여 요구사항이 현실적으로 테스트 가능한지를 검토한다.
- CASE도구 확용 일관성 분석(Consistency Analysis)을 통해 요구사항 변경사항의 추적, 분석, 관리, 표준준수 여부를 확인한다.

**인터페이스 요구사항 검증의 주요 항목**

- 완전성(Completeness)
- 일관성(Consistency)
- 명확성(Unambiguity)
- 기능성(Functionality)
- 검증 가능성(Verifiability)
- 추적 가능성(Traceability)
- 변경 용이성(Easily Changeable)

**미들웨어**

운영체제와 응용 프로그램 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어이다.

미들웨어는 표준화된 인터페이스를 제공함으로써 시스템 간의 데이터 교환에 일관성을 보장한다.

- DB(Database) 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하는 미들웨어
- RPC(Remote Procedure Call : 원격 프로시저 호출) 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 미들웨어이다.
- MOM(Message Oriented Middleware : 메시지 지향 미들웨어) 메시지 기반의 비동기형 메시지를 전달하는 미들웨어이다.
- TP-Monitor(Transaction Processing Monitor : 트랜잭션 처리 모니터) 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어 항공기나 철도 예약 업무 등 사용자 수가 증가해도 빠른 응답속도를 유지해야하는 업무에 주로 사용된다.
- ORB(Object Request Broker : 객체 요청 브로커) CORBA 표준 스펙을 구현한 객체 지향 미들웨어이다.
- WAS(Web Application Server) 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어 웹 환경을 구현하기 위한 미들웨어

**EAI(Enterprise Application Integration)**

EAI는 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션

- Point-to-Point 애플리케이션을 1:1로 연결하고, 변경 및 재사용이 어렵다.
- Hub & Spoke 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식이다. 확장 및 유지보수가 용이하다. 허브 장애 발생 시 시스템 전체에 영향을 미친다.
- Message Bus(ESB) 애플리케이션 사이에 미들웨어를 두어 처리하는 방식 확장성이 뛰어나며 대용량 처리가 가능하다.
- Bus Hybrid Hub & Spoke와 Message Bus(ESB) 방식의 혼합 방식이다. 그룹 내에서는 Hub & Spoke 방식을, 그룹 간에는 Message Bus(ESB) 방식을 이용한다. 데이터 병목 현상을 최소화할 수 있다.

![image](https://github.com/NanoKim/TIL/assets/151509995/8912bccd-a984-46b8-aef1-023d7883cec0)

**JSON(JavaScript Object Notation)**

JSON은 웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성 - 값의 쌍 형태로 표현하는 개방형 표준 포맷이다.

**AJAX(Asynchronous JavaScript and XML)**

AJAX는 javascript를 사용하여 클라이언트와 서버 간에 XML데이터를 주고 받는 비동기 통신 기술이다.

전체 페이지를 새로 고치지 않고서도 웹 페이지 일부 영역만을 업데이트 할 수 있다.

**IPSec / SSL / S-HTTP**

- IPSec(IP Security) 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜
- SSL(Secure Sockets Layer) TCP/IP 계층과 애플리케이션 계층 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜
- S-HTTP(Secure HTTP) 클라이언트와 서버 간에 전송되는 모든 메시지를 암호화 하는 프로토콜

**데이터 무결성 검사 도구**

데이터 무결성 검사 도구는 인터페이스 보안 취약점을 분석하는데 사용되는 도구이다.

시스템 파일의 변경 유무를 확인하고 파일이 변경되었을 경우 이를 관리자에게 알려준다 .

ex) Tripwire, AIDE, Samhain, Claymore, Slipwire, Fcheck 등

**인터페이스 구현 검증 도구**

인터페이스 구현을 검증하기 이한 통합 테스트를 수행하기 위해 사용하는 테스트 자동화 도구

- xUnit 테스트마다 입력과 예상 결과를 두어 자동화된 해법을 제공하는 단위테스트 프레임워크 java → JUnit, C++ → CppUnit, .Net → NUnit
- STAF 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크 크로스 플랫폼이나 분산 소프트웨어에서의 테스트환경을 조성할 수 있도록 지원한다. 분산 소프트웨어의 경우 각 분선 환경에 설체된 데몬이 프로그램 테스트에 대한 응답을 대신하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성한다.
- FitNesse 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크
- NTAF FitNesse + STAF Naver의 테스트 자동화 프레임워크
- Selenium 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크
- watir 인터프리터 방식의 객체 지향 스크립트 언어인 Ruby를 사용하는 애플리케이션 테스트 프레임워크

**APM(Application Performance Management)**

APM은 애플리케이션의 성능 관리를 위해 접속자, 자원 현황, 트랜잭션 수행 내역, 장애 진단 등 다양한 모니터링 기능을 제공하는 도구

# 6. 화면 설계
**UI/UX**

- UI(User Interface) 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어 CLI(Command Line Interface) GUI(Graphical User Interface) NUI(Natural User Interface) : 사용자의 자연스러운 움직임으로 기기를 조작
- UX(User Experience) 사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 경험

**UI의 기본 원칙**

- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함
- 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야함
- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 함
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야함

**UI 설계도구**

- 와이어프레임 페이지에 대한 개략적인 레이아웃이나 UI 요소등에 대한 뼈대를 설계하는 도구
- 목업(Mockup) 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형
- 스토리보드 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름등을 추가한 문서
- 프로토 타입 와이어프레임이나 스토리보드 등에 인터렉션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
- 유스케이스 사용자의 요구사항을 기능 단위로 표현하는 것

**ISO/IEC 9196의 소프트웨어 품질 특성**

- 기능성(Functionality) 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부를 나타낸다. 적합성, 정확성, 상호운용성, 보안성, 준수성
- 신뢰성(Reliability) 주어진 시간동안 주어진 기능을 오류 없이 수행할 수 있는 정도 성숙성, 고장 허용성, 회복성
- 사용성(Usability) 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대하여 사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도를 나타낸다. 이해성, 학습성, 운용성, 친밀성
- 효율성(Efficiency) 사용자가 요구하는 기능을 얼마나 빠르게 처리할 수 있는지 정도를 나타낸다. 시간 효율성, 자원 효율성
- 유지 보수성(Maintainability) 환경의 변화 또는 새로운 요구사항이 발생했을 때 소프트웨어를 개선하거나 확장할 수 있는 정도를 나타낸다. 분석성, 변경성, 안정성, 시험성
- 이식성(Portability) 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도를 나타낸다. 적용성, 설치성, 대체성, 공존성

# 7. 애플리케이션 테스트 관리
**애플리케이션 테스트**

애플리케이션에 잠재되어있는 결함을 찾아내는 일련의 행위 또는 절차

- 파레토 법칙(Pareto Principle) 애플리케이션의 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙
- 살충제 패러독스(Pesticide Paradox) 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상
- 오류-부재의 궤변(Absence of Errors Fallacy) 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족 시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없는것

**정적 테스트 / 동적 테스트**

- 정적 테스트 프로그램을 실행하지 않고 명세서나 소스코드를 대상으로 분석하는 테스트이다. 소스코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 등을 발견하기 위해 사용한다. ex) 워크스루, 인스펙션, 코드 검사 등
- 동적 테스트 프로그램을 실행하여 오류를 찾는 테스트 소프트웨어 개발의 모든 단계에서 테스트를 수행한다. ex) 블랙박스 테스트, 화이트박스 테스트

**시각에 따른 테스트**

- 검증(Verification) 테스트 개발자의 시각에서 제품의 생산 과정을 테스트하는 것이다. 제품이 명세서대로 완성됐는지를 테스트한다.
- 확인(Validation) 테스트 사용자의 시각에서 생산된 제품의 결과를 테스트하는 것이다. 사용자가 요구한대로 제품이 완성되었는지, 제품이 정상적으로 동작하는지를 테스트한다.

**목적에 따른 테스트**

- 회복(Recovery) 테스트 시스템에 여러가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지를 확인하는 테스트이다.
- 안전(Security) 테스트 시스템에 설치된 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지를 확인하는 테스트
- 강도(Stress) 테스트 시스템에 과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 소프트웨어가 정상적으로 실행되는지를 확인하는 테스트이다.
- 성능(Performance) 테스트 소프트웨어의 실시간 성능이나 전체적인 효율성을 진단하는 테스트로, 소프트웨어의 응답시간, 처리량 등을 테스트한다.
- 구조(Structure) 테스트 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트이다.
- 회귀(Regression)테스트 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
- 병행(Parallel) 테스트 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는 테스트

**화이트박스 테스트**

모듈의 소스코드를 오픈시킨 상태에서 소스코드의 논리적인 모든 경로를 테스트하여 테스트케이스를 설계하는 방식

소스코드의 모든 문장을 한번 이상 실행함으로써 수행된다.

**화이트박스 테스트의 종류**

- 기초 경로 검사(Base Path Testing) 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
- 제어 구조 검사(Control Structure Testing)
  - 조건 검사(Condition Testing) : 프로그램 모듈 내에 있는 논리적 조건을 테스트 하는 설계기법
  - 루프 검사(Loop Testing) : 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 설계 기법
  - 데이터 흐름 검사(Data Flow Testing) : 프로그램에서 변수의 정의와 변수 사용의 위치에서 초점을 맞춰 실시하는 테스트 설계 기법

**화이트박스 테스트의 검증 기준**

- 문장 검증 기준(Statement Coverage) 소스코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스를 설계한다.
- 분기 검증 기준(Branch Coverage) 소스코드의 모든 조건문에 ****대해 조건식의 결과가 참/거짓 인 경우가 한 번 이상 수행되도록 테스트케이스를 설계한다. 결정 검증 기준(Decision Coverage)라고도 한다.
- 조건 검증 기준(Condition Coverage) 소스코드의 조건문에 포함된 개별 조건식의 결과가 참/거짓 인 경우가 한 번 이상 수행되도록 테스트 케이스를 설계한다.
- 분기/조건 기준(Branch/Condition Coverage) 소스코드의 조건문이 참/거짓 인 경우에 따라 조건 검증 기준의 입력 데이터를 구분하는 테스트케이스를 설계한다.

**블랙박스 테스트**

소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 오나전히 작동되는 것을 입증하는 테스트로, 기능테스트 라고도 한다.

사용자의 요구사항 명세를 보면서 주로 구현된 기능을 테스트한다.

소프트웨어 인터페이스를 통해 실시된다.

**블랙박스 테스트의 종류**

- 동치 분할 검사(Equivalence Partitioning Testing) 프로그램의 입력 조건에 따라 타당한 입력자료와 타당하지 않은 입력자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법
- 경계값 분석(Boundary Value Analysis) 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법
- 원인-효과 그래프 검사(Cause-Effect Graphing Testing) 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트케이스를 선정하여 검사하는 기법
- 오류 예측 검사(Error Guessing) 과거의 경험이나 확인자의 감각으로 테스트하는 기법
- 비교 검사(Comparision Testing) 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법

**V-Model**

소프트웨어의 개발 단계에 따라

단위 테스트 → 통합테스트 → 시스템 테스트 → 인수테스트 로 분류된다.

애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현한 것을 V-Model이라고 한다.

![image](https://github.com/NanoKim/TIL/assets/151509995/d777c6f9-20f5-4639-82c0-f129f4a6dc54)

**단위 테스트(Unit Test)**

코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것이다.

사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 진행한다.

**통합테스트(Integration Test)**

단위테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트를 의미한다.

모듈간 통합된 컴포넌트 간의 상호작용 오류를 검사한다.

- 비점진적 통합 방식 : 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트하는 방법
- 점진적 통합방식 : 모듈 단위로 단계적으로 통합하면서 테스트하는 방법 → 하향식 통합 테스트, 상향식 통합테스트, 혼합식 통합 테스트

**인수 테스트(Acceptance Test)**

개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 것이다.

개발한 소프트웨어를 사용자가 직접 테스트한다.

- 알파테스트 : 사용자가 개발자 앞에서 행하는 테스트 기법
- 베타테스트 : 한명의 사용자가 여러명의 사용자 앞에서 행하는 테스트

**하향식 통합 테스트**

프로그램의 상위 모듈에서 하위 모듈로 통합하면서 테스트하는 기법이다.

- 주요 제어 모듈은 작성된 프로그램을 사용하고, 주요 제어 모듈의 종속 모듈들은 스텁으로 대체

  **Stub : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구, 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈

- BFS/DFS 등의 통합 방식에 따라 하위 모듈인 스텁들이 한번에 하나씩 실제 모듈로 교체된다.

- 모듈이 통합될 때마다 테스트를 실시한다.

- 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트를 실시한다.

**상향식 통합 테스트**

프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법

- 하위 모듈들을 클러스터(Cluster)로 결합

- 상위 모듈에거 데이터의 입출력을 확인하기 위해 더미 모듈인 드라이버를 작성한다.

  **Test Driver : 테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 도구

- 통합된 클러스터 단위로 테스트

- 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체된다.

**테스트 오라클**

테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값을 대입하여 비교하는 기법 및 활동

- True Oracle 모든 테스트케이스의 입력값에 대해 기대하는 결과를 제공, 발생된 모든 오류를 검출할 수 있음
- Sampling Oracle 틀정한 몇몇 테스트케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로 전수 테스트가 불가능한 경우 사용하는 오라클
- Heuristic(추정) Oracle 틀정 테스트케이스의 입력값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클
- Consistent(일관성 검사) Oracle 애플리케이션에 변경이 있을 때 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클

**테스트 자동화 도구**

- 정적 분석 도구(Static Analysis Tools) 프로그램을 실행하지 않고 분석하는 도구 소스코드에 대한 코딩표준, 코딩 스타일, 코드 복잡도 및 남은 결함 등을 발견하기 위해 사용된다.
- 테스트 실행 도구(Test Execution Tools) 스크립트 언어를 사용하여 테스트를 실행하는 도구 테스트 데이터와 테스트 수행 방법 등이 포함된 스크립트를 작성한 후 실행한다.
- 성능 테스트 도구(Performance Test Tools) 애플리케이션의 처리량, 응답시간, 경과시간, 자원 사용률 등을 테스트를 수행함으로써 성능의 목표 달성 여부를 확인한다.
- 테스트 통제 도구(Test Control Tools) 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구이다.
- 테스트 하네스 도구(Test Harness Tools) 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구이다.

**애플리케이션 성능 측정 지표**

- 처리량(Throughput) 일정 시간 내에 애플리케이션이 처리하는 일의 양
- 응답시간(Response Time) 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간
- 경과 시간(Turn Around Time) 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
- 자원 사용률(Resource Usage) 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률

**클린 코드 작성 원칙**

- 가독성
- 단순성
- 의존성 배제
- 중복성 최소화
- 추상화

**소스코드 품질 분석 도구**

소스코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석도구

- 정적 분석 도구(Static Analysis) 작성한 소스코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구이다. ex) pmd, cppcheck, checkstyle, ccm 등
- 동적 분석 도구(Dynamic Analysis) 작성한 소스코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구 ex) Avalanche, Valgrind

# 8. SQL 응용
__TBU__

# 9. 소프트웨어 보안 구축
**개인 키 암호화 기법(Private Key Encryption)**

개인키 암호화 기법은 동일한 키로 데이터를 암호화하고 복호화하는 암호화 기법이다 .

대칭 암호기법 또는 단일키 암호화 기법이라고도 한다.

암호화와 복호화 속도가 빠르다

관리해야 할 키의 수가 많다.

ex) LFSR, RC4, DES, AES, ARIA, SEED

**공개 키 암호화 기법(Public Key Encryption)**

공개키는 사용자에게 공개하고 복호화할 때의 비밀키는 관리자가 비밀리에 관리하는 암호화 기법

비대칭 암호 기법이라고도 한다

암호화와 복호화 속도가 느리다.

관리해야할 키의 수가 적다.

대표적으로 RSA기법이 있다.

**DES(Data Encryption Standard)**

블록 크기는 64비트, 키길이는 56비트이며 16회의 라운드를 수행한다.

컴퓨터 기술이 발달함에 따라 해독이 쉬워지면서 미국의 국가 표준이 2001년에 AES로 대체된 암호화 알고리즘

**AES(Advanced Encryption Standard)**

DES에 한계를 느낀 NIST에서 공모전을 통해 선정하였다

블록 크기는 128비트이며, 키 길이에 따라 AES-128, AES-192, AES-256으로 분류된다.

**RSA(Rivest Shamir Adleman)**

MIT에서 제안된 공개 키 암호화 알고리즘이다.

큰 숫자를 소인수분해 하기 어렵다는 것에 기반하여 만들어졌다.

공개키와 비밀키를 사용하는데 여기서 키란 메시지를 열고 잠그는 상수를 의미한다.

**해시**

해시는 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것을 의미한다.

해시함수로 변환된 값이나 키를 해시 값/ 해시키 라고 부른다.

종류로는 SHA시리즈, HAVAL, MD4, MD5, N-HASH 등…

일방향 함수이다.

**MD5**

1991년 R.Rivest가 MD4를 개선한 암호화 알고리즘

각각 512비트 짜리 입력 메시지 블록에 대해 차례로 동작한다.

모든 작업이 끝나고 나면 128비트 스테이트의 값이 변하는 알고리즘

**TKIP(Temporal Key Integrity Protocol)**

기존의 무선 랜 보안 프로토콜인 WEP의 취약성을 보완한 데이터 보안 프로토콜

암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷 당 키 할당, 키값 재설정 등의 키 관리 방식을 개선하였다.

**침입 탐지 시스템**

컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템

- 오용 탐지(Misuse Detection) : 미리 입력해 둔 공격 패턴이 감지되면 이를 알려줌
- 이상 탐지(Anomaly Detection) : 평균적인 시스템의 상태를 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려줌

**VPN(Virtual Private Network)**

인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션

암호화된 규격을 통해 인터넷 망을 전용선의 사설망을 구축한 것처럼 이용하므로 비용 부담을 줄일 수 있다.

**AAA**

AAA는 다음 3가지 기능을 기반으로 사용자의 컴퓨터 자원 접근에 대한 처리와 서비스를 제공하는 기반 구조 또는 규격을 의미한다.

- Authentication(인증) : 접근하는 사용자의 신원을 검증
- Authorization(인가) : 신원이 검증된 사용자에게 특정된 권한과 서비스를 허용하는 기능
- Accounting(과금) : 사용자가 어떤 종류의 서비스를 이용했고, 얼마만큼의 자원을 사용했는지 기록 및 보관하는 기능

**정보보호관리체계(ISMS : Information Security Management System)**

정보 자산을 안전하게 보호하기 위한 보호 절차와 대책

조직에 맞는 정보보호정책을 수립하고 위험에 상시 대응하는 여러 보안 대책을 통합 관리한다.

공공부문과 민간 기업 부문에서 이것을 평가하고 인정하는 사업을 한국 진흥원에서 운영하고 있다.

**서비스 거부 공격(DoS : Denial of Service)**

대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써 표적이 되는 서버의 정상적인 기능을 방해

- Ping of Death Ping을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비 시키는 공격방법
- SMURFING IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법이다.
- SYN Flooding 공격자가 가상의 클라이언트로 위장하여 3-way-handshake과정을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격방법
- Tear Drop 여러 개로 전송되는 패킷의 분할 순서를 알 수 있도록 Fragment Offset 값을 함께 전송하는데 이 Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인해 과부하를 발생시킴으로써 시스템이 다운되도록 하는 공격 방법
- LAND Attack(Local Area Network Denial Attack) 패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 전송 이러한 패킷이 계속해서 전송될 경우 자신에 대해 무한히 응답하게 하는 공격방법
- DDos공격(Distributed Denial of Service) 여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 서비스 거부 공격을 수행하는 것

**세션 하이재킹**

상호 인증 과정을 거친 후 접속해있는 서버와 서로 접속되어있는 클라이언트 사이의 세션 정보를 가로채는 공격

접속을 위한 인증 정보 없이도 가로챈 세션을 이용해 공격자가 클라이언트로 위장하여 서버의 자원이나 데이터를 무단으로 사용한다.

**ARP 스푸핑**

ARP의 취약점을 이용한 공격기법으로 자신의 MAC을 공격대상의 것으로 변조하여 공격대상에게 도달해야하는 데이터 패킷을 가로채거나 방해하는 기법이다.

**스니핑(Sniffing)**

네트워크의 중간에서 남의 패킷정보를 도청하는 해킹 유형, 수동적 공격에 해당한다.

**워터링 홀(Watering Hole)**

목표 대상이 자주 방문하는 웹사이트를 사전에 감염시켜 대상이 해당 사이트에 방문했을 때 악송 코드에 감염되게 하는 웹 기반 공격

**키로거 공격(Key Logger Attack)**

사용자의 키보드 움직임을 탐지해 사용자의 개인정보를 몰래 빠가는 해킹 공격

**랜섬웨어(Ransome Ware)**

인터넷 사용자의 컴퓨터에 잠입해 내부 문서나 파일들을 암호화해 사용자가 열지 못하게 하는 프로그램

암호 해독용 프로그램의 전달을 조건으로 사용자에게 돈을 요구하기도 한다.

**백도어**

시스템 설계자가 서비스 기술자나 유지 보수 프로그램 작성자의 액세스 편의를 위해 시스템 보안을 제거하여 만들어놓은 비밀 통로로 컴퓨터 범죄에 악용되기도 한다.

- 탐지 방법 무결성 검사, 열린 포트 확인, 로그 분석, set UID파일 검사등

# 10. 프로그래밍 언어 활용
__TBU__

# 11. 응용 SW 기초 기술 활용
**운영체제**

컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다.

프로세서, 기억장치, 입출력 장치, 파일 및 정보 등의 자원을 관리한다.

**운영체제의 목적에는 처리능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환시간 단축 등이 있다.

- 처리능력(Throughput) 일정 시간 내에 시스템이 처리하는 일의 양
- 반환시간(Turn Around Time) 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때 까지 걸린 시간
- 사용 가능도(Availability) 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
- 신뢰도(Reliability) 시스템이 주어진 문제를 정확하게 해결하는 정도

**UNIX**

UNIX는 1960년대 AT&T 벨 연구소, MIT, General Electric이 공동 개발한 운영체제 이다.

시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제 이다.

대부분 C언어로 작성되어 있어 이식성이 노프며, 장치, 프로세스 간의 호환성이 노다.

트리 구조의 파일 시스템을 갖는다

- 커널(Kernel) 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당한다. 프로세스(CPU 스케줄링) 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러가지 기능을 수행한다.
- 쉘(Shell) 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기이다. 사용자와 시스템 간의 인터페이스를 관리한다.

**LINUX**

1991년 Linus Torvalds가 UNIX를 기반으로 개발한 운영체제이다.

프로그램 소스코드가 무료로 공개되어 있기 때문에 프로그래머가 원하는 기능을 추가할 수 있다.

대부분의 기능이 UNIX와 동일하다.

**Android**

구글사에서 개발한 리눅스 커널 기반의 개방형 모바일 운영체제 이다.

모든 코드가 공개된 개방형 소프트웨어이다.

**기억장치 관리 - 반입 전략(Fetch)**

보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략

- 요구반입(Demand Fetch) 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법
- 예상 반입(Anticipatory Fetch) 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법

**기억장치 관리 - 배치 전략(Placement)**

새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략

- First Fit 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역중에서 첫번째 분할 영역에 배치
- Best Fit 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
- Worst Fit 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법

**주기억장치 할당 기법**

프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지를 결정하는 기법

- 연속할당 기법 : 프로그램을 주기억장치에 연속으로 할당 → 단일 분할 할당 기법, 다중 분할 할당 기법
- 분산 할당 기법 : 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법 → 페이징 기법, 세그멘테이션 기법

**가상기억장치(Virtual Memory)**

보조기억장치의 일부를 주기억장치처럼 사용하는 것으로 용량이 작은 주 기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법

프로그램을 여러개의 작은 블록 단위로 나누어서 가상 기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리한다.

- 페이징 기법(Paging) 가상기억장치에 보관되어있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법이다. 프로그램을 일정한 크기를 나눈 단위를 페이지라고 하고 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임이라고 한다.
- 세그먼테이션 기법(Segmentation) 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주 기억장치에 적재시켜 실행시키는 기법이다. 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트(Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.

**페이지 교체 알고리즘**

Page Fault가 발생하면 가상기억장치에서 필요한 페이지를 찾아 주기억장치에 적재해야하는데, 이떄 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법이 페이지 교체 알고리즘이다.

- OPT(OPTimal replacement : 최적 교체) 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법이다.
- FIFO(First In First Out) 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법
- LRU(Least Recently Used) 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
- LFU(Least Frequently Used) 사용 빈도가 가장 적은 페이지를 교체하는 기법
- NUR(Not Used Recently) 최근에 사용하지 않은 페이지를 교체하는 기법
- SCR(Second Chance Replacement) 가장 오랫동안 주기억장치에 있는 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 기법

**Locality**

프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론이다.

- 시간 구역성(Temporal Locality) 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스 하는 현상
- 공간 구역성(Spatial Locality) 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스 하는 현상

**워킹 셋**

프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합

**스래싱**

프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상

**IPv4**

8비트씩 4부분 → 32비트로 구성

네트워크 부분의 길이에 따라 A클래스에서 E클래스까지 총 5단계로 구성되어있다.

**IPv6**

16비트씩 8부분 → 128비트로 구성되어있다.

인증성, 기밀성, 데이터 무결성의 지우너으로 보안 문제를 해결할 수 있다.

- 유니캐스트(Unicast) : 1 대 1 통신
- 멀티캐스트(Multicast) : 1 대 다 통신
- 애니캐스트(AnyCast) : 1 대 다 통신, 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신

**OSI 참조 모델**

- Physical Layer(물리계층) 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의
- Data Link Layer(데이터링크 계층) 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당
- Network Layer(네트워크 계층) 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 한다.
- Transport Layer(전송 계층) 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템 간에 투명한 데이터 전송을 가능하게 한다.
- Session Layer(세션 계층) 송 수신 측 간의 관련성을 유지하고 대화 제어를 담당한다.
- Presentation Layer(표현 계층) 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층으로 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색 등의 기능을 수행한다.
- Application Layer(응용 계층) 사용자가 OSI 환경에 접근할 수 있도록 서비스를 제공한다.

**네트워크 관련 장비**

- 라우터(Router) LAN과 LAN 연결 기능에 데이터 전송의 최적 경로를 선택하는 기능이 추가된 장치이다.
- 리피터(Refeater) 거리가 증가할 수록 감쇠하는 디지털 신호의 장거리 전송을 위해 수신한 신호를 재생시키거나 출력 전압을 높여 전송하는 장치이다.
- 허브(Hub) 사무실이나 가까운 거리의 컴퓨터들을 연결하는 자잋로 각각의 회선을 통합하여 관리한다.
- 브리지(Bridge) LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹을 연결하는 장치이다. 브리지를 이용한 서브넷 구성시 전송 가능한 회선수는 브리지가 n 개일때 n(n-1)/2 개 이다.
- 게이트웨이(Gateway) OSI 전 계층의 프로토콜 구조가 다른 네트워크를 연결하는 장치이다. LAN에서 다른 네트워크에 데이터를 보내거나 받는 출입구 역할을 한다.

**프로토콜(Protocol)**

서로다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약이다.

- 구문(Syntax)
- 의미(Semantics)
- 시간(Timing)

**패킷 교환 방식 (Packet Switching)**

메시지를 일정한 길이의 패킷으로 잘라서 전송하는 방식

- 가상 회선 방식 단말기 상호 간에 논리적인 가상 통신 회선을 미리 설정하여 송신지와 수신지 사이의 연결을 확립한 후에 설정된 경로를 따라 패킷들을 순서적으로 운반하는 방식 모든 패킷의 송수신 순서가 같다.
- 데이터그램 방식 연결 경로를 설정하지 않고 인접한 노드들의 트래픽 상황을 감안하여 각각의 패킷들을 순서에 상관없이 독립적으로 운반하는 방식 패킷마다 전송 경로가 다르고, 도착한 패킷들을 수신측에서 순서를 재정리한다.

**TCP/IP**

- TCP 가상 회선 방식을 기반으로 하는 양방향 연결 서비스를 제공한다. 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공한다.
- IP 데이터 그램 방식을 기반으로 하는 비연결형 서비스를 제공한다. 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공한다.

**ARP/RARP**

- ARP(Address Resolution Protocol) 호스트의 IP 주소를 MAC으로 변환하는 기능을 수행
- RARP(Reverse ARP) MAC을 IP 주소로 변환하는 기능

**네트워크 관련 신기술**

- 메시 네트워크(Mesh Network) 차세대 이동통신, 홈 네트워킹, 공공 안전 등 특수 목적을 위한 새로운 방식의 네트워크 기술이다. 대규모 디바이스의 네트워크 생성에 최적화 되어있다.
- 피코넷(PICONET) 여러개의 독립된 통신 장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망을 형성하는 무선네트워크 기술이다.
- 애드 훅 네트워크(Ad-hoc Network) 모바일 호스트만을 이용하여 구성한 네트워크이다. 망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하다.
- 파장 분할 다중화(WDM : Wavelength Division Multiplexing) 광섬유를 이용한 통신 기술의 하나로 파장이 서로 다른 복수의 신호를 보냄으로써 여러대의 단말기가 동시에 통신 회선을 사용할 수 있도록 하는 기술이다.
- 소프트웨어 정의 데이터센터(SDDC : Software Defined Data Center) 데이터 센터의 모든 자원을 가상화하여 인력의 개입없이 소프트웨어 조작만으로 관리 및 제어되는 데이터 센터를 의미한다.
- 개방형 링크드 데이터(LOC : Linked Open Data) 누구나 사용할 수 있도록 웹상에 공개된 연계 데이터를 의미한다. 웹상에 존재하는 데이터를 개별 URI로 식별하고 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 모형이다.
- IoT(사물 인터넷) 다양한 사물들을 인터넷으로 서로 연결한 서비스 기반 기술
- 클라우드 컴퓨팅 각종 컴퓨터 자원을 중앙 컴퓨터에 두고 인터넷 기능을 갖는 단말기로 언제 어디서나 인터넷을 통해 컴퓨터 작업을 수행할 수 있는 가상화된 환경
- USN(Ubiquitous Sensor Network) 각종 센서로 수집한 정보를 무선으로 수집할 수 있도록 구성한 네트워크이다.

**NAT(Network Address Translation : 네트워크 주소 변환)**

NAT는 한개의 정식 IP 주소에 대량의 가상 시설 IP 주소를 할당 및 연결하는 기능이다.

**IGP(Interior Gateway Protocol)**

하나의 자율 시스템 (AS)내의 라우팅에 사용되는 프로토콜이다.

- RIP(Routing Information Protocol) 최단 경로 탐색에 벨만포드 알고리즘을 사용한다. 소규모 동종의 네트워크 내에서 효율적인 방법이다.
- OSPF(Open Shortest Path First protocol) RIP 의 단점을 해결하여 새로운 기능을 지원하는 인터넷 프로토콜로 대규모 네트워크에서 많이 사용된다. 최단 경로 탐색에 다익스트라 알고리즘을 사용한다.

**SW 관련 신기술**

- 블록체인 P2P 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자의 디지털 장비에 분산 저장하는 기술이다.
- 매시업(Mashup) 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술로
- 다수의 정보원이 제공하는 콘텐츠를 조합하여 하나의 서비스로 제공하는 웹사이트 또는 애플리케이션을 말한다.
- 서비스 지향 아키텍처(SOA : Service Oriented Architecture) 기업의 인프라인 정보시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아케텍처이다.
- 디지털 트윈 현실속의 사물을 소프트웨어로 가상화한 모델이다.
- 그레이웨어 사용자 입장에서 유용할 수도 있고, 악의적일 수도 있는 애드웨어, 트랙웨어, 기타 악성 코드나 악성 공유 웨어
- 양자 암호키 분배(QKD : Quantum Key Distribution) 양자 통신을 위해 비밀키를 분배하여 관리하는 기술
- 서비스형 소프트웨어 (SaaS : Software as a Service) 사용자가 필요로 하는 서비스만 이용할 수 있도록 한 소프트웨어
- 시맨틱 웹 (Semantic Web) 컴퓨터가 사람을 대신하여 정보를 읽고 이해하고 가공하여 새로운 정보를 만들어낼 수 있도록 이해하기 쉬운 의미를 가진 차세대 지능형 웹을 의미한다.
- 리치 인터넷 애플리케이션(RIA : Rich Internet Application) 플래시 애니메이션 기술과 웹 서버 애플리케이션 기술을 통합하여 기존 HTML보다 역동적이고 인터랙티브한 웹 페이지를 제공하는 신 개념의 웹 페이지 제작 기술

**HW 관련 신기술**

- 앤스크린(N-Screen) N개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스이다.
- 신 클라이언트 PC(Thin Client PC) 하드디스크나 주변 장치 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터
- 엠디스크(M-DISC) 한번의 기록만으로 자료를 영구보관할 수 있는 광 저장장치
- 멤스(MEMS : Micro-Electro Mechanical System) 초정밀 반도체 제조 기술을 바탕으로 센서, 액추에이어 등 기계 구조를 다양한 기술로 미세 가공하여 전기 기계적 동작을 할 수 있도록 한 초미세 장치
- 멤리스터(Memrister) 메모리와 레지스터의 합성어로 전류의 방향과 양 등 기존의 경험을 모두 기억하는 특별한 소자
- 트러스트존 기술(TrushZone Technology) 하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반 구역과 보안이 필요한 애플리케이션을 처리하는 보안구역으로 분할하여 관리하는 하드웨어 기반의 보안기술

**RAID(Redundant Array of Independent Disk)**

- RAID0 스트라이핑 디스크를 병렬로 연결하여 디스크의 개수만큼 용량과 속도가 배로 증가한다. 하나의 디스크만 손상되어도 전체 데이터가 파손된다.
- RAID1 미러링 같은 데이터를 다른 디스크에 동일하게 복사하는 방식

**Secure OS**

기존 OS에 내재된 보안 취약점을 해소하기 위하여 보안 기능을 갖춘 커널을 이식하여 되부의 침입으로부터 시스템 자원을 보호하는 운영체제

식별 및 인증, 임의적/강제적 접근 통제, 객체 재사용 보호, 완전한 조정, 신뢰 경로, 감사 및 감사기록 축소 등

**DB 관련 신기술**

- 하둡(Hadoop) 오픈소스를 기반으로 한 분산 컴퓨팅 플랫픔 일반 PC 급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬ㄹ로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크
- 맵리듀스(MapReduce) 대용량 데이터를 분산처리하기 위한 목적으로 개발된 프로그래밍 모델 흩어져 있는 데이터를 연관성 있는 데이터 분류로 묶는 Map 작업을 수행한 후 중복 데이터를 제거하고 원하는 데이터를 추출하는 Reduce 작업을 수행한다.
- 데이터마이닝(Data Mining) 대량의 데이터를 분석하여 데이터에 내재된 변수 사이의 상호 관계를 규명하여 일정한 패턴을 찾아내는 기법
- 타조(Tajo) 오픈소스 기반 분산 컴퓨팅 플랫폼인 아파치 하둡 기반의 분산데이터 웨어 하우스 프로젝트이다.
- OLAP(Online Analytical Processing) 다차원으로 이루어진 데이터로부터 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식이다.
- 브로드 데이터(Broad Data) 다양한 채널에서 소비자와 상호 작용을 통해 생성된 것으로 기업 마케팅에 있어 효율적이고 다양한 데이터이며, 이전에 사용하지 않거나 알지 못했던 새로운 데이터나 기존 데이터에 새로운 가치가 더해진 데이터이다.

**회복**

회복은 트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업

연기 갱신 기법, 즉각 갱신 기법, 그림자 페이지 대체 기법, 검사점 기법

**REDO/UNDO**

- REDO 데이터베이스가 비정상적으로 종료되었을 때 디스크에 저장된 로그를 분석하여 트랜잭션의 시작과 완료에 대한 기록이 있는 트랜잭션들의 작업을 재작업한다. 로그를 이용하여 해당 데이터 항목에 대해 이전 값을 이후 값으로 변경하는 연산
- UNDO 데이터베이스가 비정상적으로 종료되었을 때 디스크에 저장된 로그를 분석하여 트랜잭션의 시작에 대한 기록은 있지만 완료 기록은 없는 트랜잭션들이 작업한 변경 내용들을 모두 취소한다. 로그를 이용하여 해당 데이터 항목에 대해 이후 값을 이전 값으로 변경하는 연산

**연기 갱신 기법(Deferred Update)**

트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 방법

REDO 작업만 가능하다.

**즉각 갱신 기법(Immediate Update)**

트랜잭션이 데이터를 갱신하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 기법

REDO / UNDO 작업이 가능하다.

**로킹(Locking)**

트랜잭션들이 어떤 로킹 단위를 액세스 하기 전에 Lock을 요청해서 Lock이 허락되어야만 그 로킹 단위를 액세스 할 수 있도록 하는 기법

주로 데이터의 액세스를 상호 배타적으로 한다.

**로킹 단위**

병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기

데이터베이스, 파일, 레코드, 필드 등이 될 수 있다.

로킹 단위가 크면 → 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아진다.

로킹 단위가 작으면 → 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하지만, 병행성 수준이 높아진다.

# 12. 제품소프트웨어 패키징
__TBU__
